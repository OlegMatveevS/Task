# Task 1
Зная основые работы операции в двоичной системе счисления, можно воспользоваться знанием того, что четные числа в двоичном коде всегда оканчиваются на 0, тогда
лекго можно привести несколько примеров проверки четности числа. 
1. Использование AND оператора.
```C++
bool isEven(int n)
{
    return (!(n & 1));
}
```
2. Использование XOR оператора. 
```C++
bool isEven(int n)
{
    return ((n | 1) > n);
}
```
3. Использование OR оператора.
```C++
bool isEven(int n)
{
    return (n ^ 1 == n + 1);
}
```
4. Функция из задания.
```C++ 
bool isEven(int value)
{
    return value%2==0;
}
```
Проведем дизассемблинг gcc 12.2
![image](https://user-images.githubusercontent.com/55399599/194369449-4229ed4e-1c69-499e-9c49-8865085711de.png)

Как видим, в предлагаемой заданием функцией также используется оператор AND как и в первой моей реализации четности.
Вероятно компиляторы для языков, где эти выражения эквивалентны, будут одинаково реализовывать оба варианта.
В целом clang сгенерировал лучший код, за ним следует MSVC, а затем gcc. icc сгенерировал действительно ужасный код для функции n % 2. 

# Task 2
Первая реализация кругового буфера реализована с помощью массива и указателей, в классе реализована функция для динамического расширения, однако достаточно убрать
проверку на заполнения массива и буфер будет перезаписывающимся или также возможно установить ограничение на запись при заполнении, тогда буфер станет фиксированным

https://github.com/OlegMatveevS/Task/blob/main/TaskTwo/RingBuffer.cpp

Вторая реализация выполнена на списках, 
Циклический связанный список имеет то же преимущество перед кольцевым буфером, что и связный список перед фиксированным массивом. 
Он может различаться по размеру, и вы можете вставлять и элементы без перетасовки.
Из недостатков: нет доступа к массиву O (1) и увеличивается объем работы, если вы расширяете или сжимаете список.

https://github.com/OlegMatveevS/Task/blob/main/TaskTwo/RingBufferList.cpp

Фиксированный кольцевой буфер обычно используется при известном количестве элементов
буфер на списках более гибок в доступе и размещении элементов.

