# Task 1
Зная основые работы операции в двоичной системе счисления, можно воспользоваться знанием того, что четные числа в двоичном коде всегда оканчиваются на 0, тогда
легко можно привести несколько примеров проверки четности числа. 
1. Использование AND оператора.
```C++
bool isEven(int n)
{
    return (!(n & 1));
}
```
2. Использование XOR оператора. 
```C++
bool isEven(int n)
{
    return ((n | 1) > n);
}
```
3. Использование OR оператора.
```C++
bool isEven(int n)
{
    return (n ^ 1 == n + 1);
}
```
4. Функция из задания.
```C++ 
bool isEven(int value)
{
    return value%2==0;
}
```
Проведем дизассемблинг gcc 12.2
![image](https://user-images.githubusercontent.com/55399599/194369449-4229ed4e-1c69-499e-9c49-8865085711de.png)

Как видим, в предлагаемой заданием функцией также используется оператор AND как и в первой моей реализации четности.
Вероятно компиляторы для языков, где эти выражения эквивалентны, будут одинаково реализовывать оба варианта.
Проведем бенчмарк, подав на вход каждой функции числа от 0 до 2000000000, используем компилятор clang

The time for %2: 6.562500 seconds

The time for XOR: 4.546875 seconds

The time for OR: 4.218750 seconds

The time for AND: 4.078125 seconds

Как мы видим, худший результат выдает %2 ввиду операции деления, остальные функции показывают неплохое время, AND - лучшее
Проведем бенчмарк, используя другой компилятор 

# Task 2
Первая реализация кругового буфера реализована с помощью массива и указателей, в классе реализована функция для динамического расширения, однако достаточно убрать
проверку на заполнения массива и буфер будет перезаписывающимся или также возможно установить ограничение на запись при заполнении, тогда буфер станет фиксированным

https://github.com/OlegMatveevS/Task/blob/main/TaskTwo/RingBuffer.cpp

Вторая реализация выполнена на списках, 
Циклический связанный список имеет то же преимущество перед кольцевым буфером, что и связный список перед фиксированным массивом. 
Он может различаться по размеру, и вы можете вставлять и элементы без перетасовки.
Из недостатков: нет доступа к массиву O (1) и увеличивается объем работы, если вы расширяете или сжимаете список.

https://github.com/OlegMatveevS/Task/blob/main/TaskTwo/RingBufferList.cpp

Фиксированный кольцевой буфер обычно используется при известном количестве элементов
буфер на списках более гибок в доступе и размещении элементов.

# Task 3
Ввиду того, что для разных случайных значений, разные алгоритмы сортировки будут выдавать разные результаты предложить самый быстрый алгоритм невозможно
Можно лишь предположить лучшие варианты, и чем больше сведений о получаемых значений, тем лучше алгоритм может быть предложен, т.к определенные алгоритмы
могут демонстрировать отличную скорость, однако в худших случаях их скорость будет уступать иным алгоритмам. Предполагаю что пояснение того, о том, что 
Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным) как раз таки и намекает о том, что не ожидается предаставление 
какого-либо алгоритма.
